import{Y as B,r as f,Z as C,$ as A,a0 as x,a1 as P,G as S,m as O,a2 as E,N as T,K as U,a3 as m,u as I,c as h}from"./entry.kYc8B6H9.js";const M=s=>s==="defer"||s===!1;function v(...s){var w;const u=typeof s[s.length-1]=="string"?s.pop():void 0;typeof s[0]!="string"&&s.unshift(u);let[t,c,e={}]=s;if(typeof t!="string")throw new TypeError("[nuxt] [asyncData] key must be a string.");if(typeof c!="function")throw new TypeError("[nuxt] [asyncData] handler must be a function.");const a=O(),p=()=>null,y=()=>a.isHydrating?a.payload.data[t]:a.static.data[t];e.server=e.server??!0,e.default=e.default??p,e.getCachedData=e.getCachedData??y,e.lazy=e.lazy??!1,e.immediate=e.immediate??!0,e.deep=e.deep??B.deep,e.dedupe=e.dedupe??"cancel";const d=()=>![null,void 0].includes(e.getCachedData(t));if(!a._asyncData[t]||!e.immediate){(w=a.payload._errors)[t]??(w[t]=null);const o=e.deep?f:C;a._asyncData[t]={data:o(e.getCachedData(t)??e.default()),pending:f(!d()),error:A(a.payload._errors,t),status:f("idle")}}const r={...a._asyncData[t]};r.refresh=r.execute=(o={})=>{if(a._asyncDataPromises[t]){if(M(o.dedupe??e.dedupe))return a._asyncDataPromises[t];a._asyncDataPromises[t].cancelled=!0}if((o._initial||a.isHydrating&&o._initial!==!1)&&d())return Promise.resolve(e.getCachedData(t));r.pending.value=!0,r.status.value="pending";const i=new Promise((n,l)=>{try{n(c(a))}catch(b){l(b)}}).then(n=>{if(i.cancelled)return a._asyncDataPromises[t];let l=n;e.transform&&(l=e.transform(n)),e.pick&&(l=R(l,e.pick)),a.payload.data[t]=l,r.data.value=l,r.error.value=null,r.status.value="success"}).catch(n=>{if(i.cancelled)return a._asyncDataPromises[t];r.error.value=E(n),r.data.value=T(e.default()),r.status.value="error"}).finally(()=>{i.cancelled||(r.pending.value=!1,delete a._asyncDataPromises[t])});return a._asyncDataPromises[t]=i,a._asyncDataPromises[t]};const g=()=>r.refresh({_initial:!0}),_=e.server!==!1&&a.payload.serverRendered;{const o=U();if(o&&!o._nuxtOnBeforeMountCbs){o._nuxtOnBeforeMountCbs=[];const n=o._nuxtOnBeforeMountCbs;o&&(x(()=>{n.forEach(l=>{l()}),n.splice(0,n.length)}),P(()=>n.splice(0,n.length)))}_&&a.isHydrating&&(r.error.value||d())?(r.pending.value=!1,r.status.value=r.error.value?"error":"success"):o&&(a.payload.serverRendered&&a.isHydrating||e.lazy)&&e.immediate?o._nuxtOnBeforeMountCbs.push(g):e.immediate&&g(),e.watch&&S(e.watch,()=>r.refresh());const i=a.hook("app:data:refresh",async n=>{(!n||n.includes(t))&&await r.refresh()});o&&P(i)}const D=Promise.resolve(a._asyncDataPromises[t]).then(()=>r);return Object.assign(D,r),D}function R(s,u){const t={};for(const c of u)t[c]=s[c];return t}function k(s){return $fetch("http://localhost:3001/players/Player",{method:"POST",body:{tag:s}})}function H(){return $fetch("https://api.brawlapi.com/v1/brawlers",{method:"GET"})}function $(){return $fetch("https://api.brawlapi.com/v1/icons",{method:"GET"})}const G=m("UserInfoStore",()=>{const s=I(),u=f(),t=h(()=>{if(u.value)return u.value.brawlers});async function c(a){const{data:p}=await v("postPlayerAPI",()=>k(a));console.log(p.value);const{code:y,message:d,dataInfo:r}=p.value;switch(y){case 200:e(r),s.push({path:"userPage"});return;default:alert(d);return}}function e(a){u.value=a}return{UserInfo:u,UserBrawlers:t,setUserInfo:e,submitTag:c}}),j=m("BrawlersStore",()=>{const s=f([]);async function u(){const{data:c}=await v("getAllBrawlersAPI",()=>H()),{list:e}=c.value;e&&t(e)}function t(c){s.value=c}return{Brawlers:s,getAllBrawlers:u}}),K=m("IconsStore",()=>{I();const s=f({}),u=h(()=>s.value.player?s.value.player:{}),t=h(()=>s.value.club?s.value.club:{});async function c(){const{data:a}=await v("getIconsAPI",()=>$());a.value&&e(a.value)}function e(a){s.value=a}return{Icons:s,PlayerIcons:u,ClubIcons:t,setIcons:e,getIcons:c}});export{j as a,K as b,G as u};
